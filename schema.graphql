type AuthPayload {
  accessToken: String!
  refreshToken: String!
  user: User!
}

input CreateUserInput {
  userName: String!
  email: EmailAddress!
  password: String!
}

input LoginInput {
  email: EmailAddress!
  password: String!
}

type LogoutResponse {
  loggedOut: Boolean!
}

type NewTokenResponse {
  accessToken: String!
  refreshToken: String!
}

type Query {
  hello: String!
  findAllBuilds: [Build]
  findOneBuild: Build
  usersBuilds: [Build]
  findBuildUsers(buildId: String!): [BuildUser]
  findFolloweddUsersBuildPermission(buildId: String!): [UserBuildPermission]
  ingredients: [Ingredient]!
  ingredient(id: Int!): Ingredient
  recipeList: [ListItem]!
  recipes: [Recipe]!
  recipe(name: String!): Recipe
  allUsers: [User]!
  userById(id: ID!): User
  findFollows: [User]
  findFollowers: [User]
  getUserRelationships: [UserRelationship]
}

type Mutation {
  login(loginInput: LoginInput!): AuthPayload!
  signup(createUserInput: CreateUserInput!): AuthPayload!
  logout(userId: ID!): LogoutResponse!
  getNewTokens(refreshToken: String): AuthPayload!
  createBuild(createBuildInput: CreateBuildInput): Build
  updateBuild(updateBuildInput: UpdateBuildInput): ArchiveResponse
  removeBuild(buildId: String, permission: Permission): Build
  changeBuildPermission(
    changeBuildPermissionInput: ChangeBuildPermissionInput
  ): BuildPermissionResponse
  deleteBuildPermission(
    changeBuildPermissionInput: ChangeBuildPermissionInput
  ): BuildPermissionResponse
  createIngredient(createIngredientInput: CreateIngredientInput!): Ingredient!
  createManyIngredients(
    createManyIngredientInputs: [CreateIngredientInput]!
  ): StatusMessage!
  updateIngredient(updateIngredientInput: UpdateIngredientInput!): Ingredient!
  removeIngredient(id: String!): Ingredient
  createManyRecipes(
    createManyRecipeInputs: [CreateRecipeInput]!
  ): StatusMessage!
  createRecipe(createRecipeInput: CreateRecipeInput!): Recipe!
  updateRecipe(updateRecipeInput: UpdateRecipeInput!): Recipe!
  removeRecipe(id: ID!): Recipe
  updateTouch(
    newTouchArray: [TouchInput]
    permission: Permission
    buildId: String
    version: Int
  ): [Touch]
  followUser(followId: String!, relationship: Relationship): StatusMessage
  unFollowUser(unfollowId: String!): StatusMessage
  blockUser(blockId: String!): StatusMessage
  unblockUser(unblockId: String!): StatusMessage
}

type Build {
  id: ID!
  recipe: Recipe!
  buildName: String!
  createdAt: DateTime
  editedAt: DateTime
  createdBy: User
  editedBy: User
  instructions: String
  notes: String
  glassware: String
  ice: String
  permission: Permission
  touch: [Touch!]!
  version: Int
  archivedBuild: [ArchivedBuild]
}

type ArchivedBuild {
  id: ID!
  buildId: ID!
  buildName: String!
  createdAt: DateTime
  createdBy: User
  instructions: String
  notes: String
  glassware: String
  ice: String
  version: Int
  archivedTouch: [ArchivedTouch]
}

type BuildUser {
  user: User!
  build: Build!
  permission: Permission
}

type UserBuildPermission {
  user: User!
  permission: String
}

input BuildConstructor {
  newRecipe: Boolean!
  recipeName: String!
  buildName: String!
  about: String!
  glassware: String!
  ice: String!
  instructions: String!
  touchArray: [Touch]!
}

type ArchiveResponse {
  build: Build
  archivedBuild: ArchivedBuild
}

type BuildPermissionResponse {
  buildUser: BuildUser
  status: StatusMessage
}

input CreateBuildInput {
  recipe: RecipeNameInput!
  buildName: String!
  instructions: String
  glassware: String
  ice: String
  touchArray: [TouchInput]!
}

input RecipeNameInput {
  name: String!
}

input CreateFirstBuildInput {
  buildName: String!
  instructions: String
  glassware: String
  ice: String
  touchArray: [TouchInput]!
}

input UpdateBuildInput {
  recipeName: String
  buildId: String!
  buildName: String
  instructions: String
  glassware: String
  ice: String
  touchArray: [TouchInput]!
  permission: Permission
}

input ChangeBuildPermissionInput {
  userId: String
  buildId: String
  userPermission: Permission
  desiredPermission: Permission
}

enum Permission {
  VIEW
  EDIT
  MANAGER
  OWNER
  BLOCKED
}

enum Relationship {
  Favorite
  Close
  Following
  Blocked
}

type ListItem {
  id: String!
  name: String!
}

type Ingredient {
  id: ID!
  name: String!
  description: String
}

input CreateIngredientInput {
  name: String!
  description: String
}

input UpdateIngredientInput {
  id: ID!
  name: String!
  description: String
}

type Recipe {
  id: ID!
  createdAt: DateTime
  editedAt: DateTime
  name: String!
  about: String
  createdBy: User
  editedBy: User
  build: [Build!]!
}

input CreateRecipeInput {
  recipeName: String!
  about: String!
  build: CreateFirstBuildInput!
}

input UpdateRecipeInput {
  id: ID!
  name: String
  about: String
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""
A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address.
"""
scalar EmailAddress

type Touch {
  id: ID!
  build: Build
  order: Int
  amount: Float
  unit: String
  version: Int
  ingredient: Ingredient
}

type ArchivedTouch {
  id: ID!
  archivedBuild: Build
  order: Int
  amount: Float
  unit: String
  version: Int
  ingredient: Ingredient
}

input TouchInput {
  ingredientName: String
  amount: Float
  unit: String
}

type CompleteTouch {
  id: ID!
  ingredientName: String
  amount: Float
  unit: String
  cost: Float
}

type User {
  id: ID!
  userName: String!
  email: EmailAddress
  dateJoined: DateTime
  lastEdited: DateTime
  following: [Following]
  followedBy: [Follower]
  myBuild: [Build]
  allBuilds: [Build]
  buildEditedBy: [Build]
}

input UpdateUserInput {
  id: ID!
  userName: String
  email: String
}

type Following {
  id: ID!
  userName: String!
  email: EmailAddress
  dateJoined: DateTime
  lastEdited: DateTime
  relationship: Relationship
}

type Follower {
  id: ID!
  userName: String!
  email: EmailAddress
  dateJoined: DateTime
  lastEdited: DateTime
}

type StatusMessage {
  message: String
}

type FollowReturn {
  following: String
  relationship: Relationship
  status: StatusMessage
}

type UserRelationship {
  user: User!
  followedBy: Boolean
  following: Boolean
}
